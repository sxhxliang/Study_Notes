# 操作系统和网络

## TCP-IP 三次握手和四次握手

![](https://images2015.cnblogs.com/blog/735653/201608/735653-20160802153108872-1434533909.jpg)

- 服务器接收到 SYN 包时，此时的 TCP 链接称作半链接，将被服务端内核放入半链接队列
- 服务器接收到 ACK 包时，将会从半链接队列中找到该链接，弹出它，并添加到完成三次握手的链接队列中。

#### 为什么会有 TIME_WAIT ?

从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入。从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指`Max Segment Lifetime`，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。

TIME_WAIT状态的存在有两个理由:

1. 让4次握手关闭流程更加可靠：4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会重新发送之前丢失的ACK包。

2. 防止lost duplicate对后续新建正常链接的传输造成破坏：lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。TCP通过超时重传机制重发FIN + ACK包，使得这些旧的 lost package 被抛弃。

## 2. 系统调用 
[系统调用详解](https://blog.csdn.net/gatieme/article/details/50779184)

linux内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。

一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由`int $0x80`指令产生，而128号异常处理程序就是系统调用处理程序`system_call()`。

### 2.1 API 与 系统调用
- 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能，因此，**API是一个提供给应用程序的接口**，一组函数，是与程序员进行直接交互的。
- 系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。
- 并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）

### 2.2 内核态 与 用户态
**内核态**：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

**用户态**：当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。

内核态执行的代码是是操作系统特有的，代码一般简单精炼。应用程序通过系统调用进入内核态执行达到实际访问计算机其他资源的目的。

### 2.3 常见的系统调用
常见的unix系统调用主要分为三类：文件操作系统的系统调用，控制类的系统调用，信号和时间类的调用。

1. 文件操作的系统调用
- create ，open，read，write，close，link，unlink，lseek，chmod，rename (打开，关闭，读写，链接，取消链接，建立文件)
- lseek 设定文件的读写位置
- chmod 改变对文件的访问权限
- rename 更改文件名

2. 控制类系统调用
- fork 创建一个子进程
- wait 父进程等待子进程终止
- exit 终止子进程的执行
- exec 启动执行一个指定文件

3. 信号与时间的系统调用
UNIX把出现的异常情况或异步事件以传送信号的方式进行，与信号有关的系统调用主要有：
- kill 把信号传送给一个或几个相关进程
- sigaction 声明准备接收的信号类型
- sigreturn 从信号返回，继续执行被信号中断的操作

4. UNIX用于时间管理的系统调用主要有：
- stime 设置日历时间
- time 获得日历时间
- times 获得执行所花费的时间
