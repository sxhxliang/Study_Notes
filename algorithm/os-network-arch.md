# 操作系统和网络

## 1. TCP-IP 三次握手和四次握手

![](https://images2015.cnblogs.com/blog/735653/201608/735653-20160802153108872-1434533909.jpg)

- 服务器接收到 SYN 包时，此时的 TCP 链接称作半链接，将被服务端内核放入半链接队列
- 服务器接收到 ACK 包时，将会从半链接队列中找到该链接，弹出它，并添加到完成三次握手的链接队列中。

### 1.1 为什么会有 TIME_WAIT ?

从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入。从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指`Max Segment Lifetime`，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。

### 1.2 TIME_WAIT状态的存在有两个理由:

1. 让4次握手关闭流程更加可靠：4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会重新发送之前丢失的ACK包。

2. 防止lost duplicate对后续新建正常链接的传输造成破坏：lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。TCP通过超时重传机制重发FIN + ACK包，使得这些旧的 lost package 被抛弃。

## 2. 系统调用 
[系统调用详解](https://blog.csdn.net/gatieme/article/details/50779184)

linux内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。

一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由`int $0x80`指令产生，而128号异常处理程序就是系统调用处理程序`system_call()`。

### 2.1 API 与 系统调用
- 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能，因此，**API是一个提供给应用程序的接口**，一组函数，是与程序员进行直接交互的。
- 系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。
- 并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）

### 2.2.1 内核态 与 用户态
![](https://upload-images.jianshu.io/upload_images/2744546-2b78e131a118b774.png?imageMogr2/auto-orient/strip|imageView2/2/w/366/format/webp)
- 内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。
- 用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。
- 系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。

![](https://upload-images.jianshu.io/upload_images/2744546-cc53e9112a785a83.png?imageMogr2/auto-orient/strip|imageView2/2/w/742/format/webp)


### 2.2.2 用户态与内核态的切换
用户态切换为内核态的三种情况：
- 系统调用 (软中断)
- 异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。
- 外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。

系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为**软中断**。从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。


### 2.3 常见的系统调用
常见的unix系统调用主要分为三类：文件操作系统的系统调用，控制类的系统调用，信号和时间类的调用。

1. 文件操作的系统调用
- create ，open，read，write，close，link，unlink，lseek，chmod，rename (打开，关闭，读写，链接，取消链接，建立文件)
- lseek 设定文件的读写位置
- chmod 改变对文件的访问权限
- rename 更改文件名

2. 控制类系统调用
- fork 创建一个子进程
- wait 父进程等待子进程终止
- exit 终止子进程的执行
- exec 启动执行一个指定文件

3. 信号与时间的系统调用
UNIX把出现的异常情况或异步事件以传送信号的方式进行，与信号有关的系统调用主要有：
- kill 把信号传送给一个或几个相关进程
- sigaction 声明准备接收的信号类型
- sigreturn 从信号返回，继续执行被信号中断的操作

4. UNIX用于时间管理的系统调用主要有：
- stime 设置日历时间
- time 获得日历时间
- times 获得执行所花费的时间

## 3. 死锁
死锁: 多个进程因循环等待资源而造成无法执行的现象。

死锁会造成进程无法执行，同时会造成系统资源的极大浪费(资源无法释放)。

死锁产生的4个必要条件：

1. 互斥使用(Mutual exclusion)

指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

2. 不可抢占(No preemption)

指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

3. 请求和保持(Hold and wait)

指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

4. 循环等待(Circular wait) 

指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

### 死锁避免：银行家算法

思想: 判断此次请求是否造成死锁若会造成死锁，则拒绝该请求

