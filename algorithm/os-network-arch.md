# 操作系统和网络

## TCP-IP 三次握手和四次握手

![](https://images2015.cnblogs.com/blog/735653/201608/735653-20160802153108872-1434533909.jpg)

- 服务器接收到 SYN 包时，此时的 TCP 链接称作半链接，将被服务端内核放入半链接队列
- 服务器接收到 ACK 包时，将会从半链接队列中找到该链接，弹出它，并添加到完成三次握手的链接队列中。

#### 为什么会有 TIME_WAIT ?

从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入。从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指`Max Segment Lifetime`，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。

TIME_WAIT状态的存在有两个理由:

1. 让4次握手关闭流程更加可靠：4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会重新发送之前丢失的ACK包。

2. 防止lost duplicate对后续新建正常链接的传输造成破坏：lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。TCP通过超时重传机制重发FIN + ACK包，使得这些旧的 lost package 被抛弃。

## 系统调用
linux内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。

一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由`int $0x80`指令产生，而128号异常处理程序就是系统调用处理程序`system_call()`。
